**Inter-Process Communication (IPC) in C++** refers to the mechanisms that allow different processes (running programs) to communicate and exchange data. Since processes have isolated memory spaces, IPC is essential when one process needs to interact with another, especially in client-server architectures, distributed systems, or parallel computation.

---

## üß† **Why IPC is Needed?**

* Sharing data between independent processes
* Synchronization between processes
* Resource sharing (files, memory, ports)
* Command/control communication

---

## üõ†Ô∏è **Common IPC Mechanisms (with C++ Usage)**

### 1. **Pipes (Unnamed Pipes)**

* **Unidirectional** communication.
* Only between **related processes** (parent-child).

#### Example:

```cpp
#include <unistd.h>
#include <iostream>

int main() {
    int fd[2];
    pipe(fd);

    if (fork() == 0) {
        // Child process
        close(fd[1]); // Close write end
        char buffer[100];
        read(fd[0], buffer, sizeof(buffer));
        std::cout << "Child read: " << buffer << "\n";
    } else {
        // Parent process
        close(fd[0]); // Close read end
        const char* msg = "Hello from parent";
        write(fd[1], msg, strlen(msg)+1);
    }
    return 0;
}
```

---

### 2. **Named Pipes (FIFOs)**

* Work between **unrelated processes**.
* Appear as special files in the filesystem.

#### Usage:

```bash
mkfifo /tmp/myfifo
```

#### Example (writer):

```cpp
#include <fcntl.h>
#include <unistd.h>

int main() {
    int fd = open("/tmp/myfifo", O_WRONLY);
    write(fd, "Hello FIFO", 10);
    close(fd);
}
```

#### Example (reader):

```cpp
#include <fcntl.h>
#include <unistd.h>
#include <iostream>

int main() {
    int fd = open("/tmp/myfifo", O_RDONLY);
    char buffer[100];
    read(fd, buffer, sizeof(buffer));
    std::cout << "Read from FIFO: " << buffer << "\n";
    close(fd);
}
```

---

### 3. **Message Queues**

* Send structured messages between processes.
* More flexible than pipes.

#### POSIX Example:

```cpp
#include <mqueue.h>
#include <cstring>
#include <iostream>

int main() {
    mqd_t mq = mq_open("/myqueue", O_CREAT | O_WRONLY, 0644, NULL);
    const char* msg = "Hello Queue";
    mq_send(mq, msg, strlen(msg)+1, 0);
    mq_close(mq);
    return 0;
}
```

---

### 4. **Shared Memory**

* Fastest IPC method.
* Requires synchronization (e.g., semaphores).

#### POSIX Example:

```cpp
#include <sys/mman.h>
#include <fcntl.h>
#include <unistd.h>
#include <cstring>
#include <iostream>

int main() {
    int fd = shm_open("/myshm", O_CREAT | O_RDWR, 0666);
    ftruncate(fd, 1024);
    void* addr = mmap(0, 1024, PROT_WRITE, MAP_SHARED, fd, 0);
    strcpy((char*)addr, "Shared Memory Message");
    munmap(addr, 1024);
    close(fd);
    return 0;
}
```

---

### 5. **Semaphores**

* Used to synchronize access to shared resources.

#### POSIX Example:

```cpp
#include <semaphore.h>
#include <fcntl.h>
#include <iostream>

int main() {
    sem_t* sem = sem_open("/mysem", O_CREAT, 0644, 1);
    sem_wait(sem);
    // critical section
    std::cout << "Inside critical section\n";
    sem_post(sem);
    sem_close(sem);
    return 0;
}
```

---

### 6. **Sockets**

* Used for IPC over a **network** or **localhost**.
* Supports client-server model, bidirectional communication.

#### Example (TCP server):

```cpp
#include <sys/socket.h>
#include <netinet/in.h>
#include <unistd.h>
#include <cstring>
#include <iostream>

int main() {
    int server_fd = socket(AF_INET, SOCK_STREAM, 0);
    sockaddr_in address = {AF_INET, htons(8080), INADDR_ANY};

    bind(server_fd, (sockaddr*)&address, sizeof(address));
    listen(server_fd, 3);

    int client_fd = accept(server_fd, NULL, NULL);
    char buffer[100];
    read(client_fd, buffer, 100);
    std::cout << "Received: " << buffer << "\n";
    close(client_fd);
    close(server_fd);
}
```

---

## üß© **Comparison Table**

| Method        | Bidirectional? | Related Processes Only? | Speed     | Persistent? | Complexity |
| ------------- | -------------- | ----------------------- | --------- | ----------- | ---------- |
| Pipe          | No             | Yes                     | Fast      | No          | Low        |
| FIFO          | Yes            | No                      | Fast      | Yes         | Low        |
| Message Queue | Yes            | No                      | Moderate  | Yes         | Medium     |
| Shared Memory | Yes            | No                      | Very Fast | No          | Medium     |
| Semaphore     | N/A            | No                      | Fast      | Yes         | Medium     |
| Socket        | Yes            | No                      | Moderate  | Yes         | High       |

---

## üîê **Security and Synchronization**

* Use **semaphores or mutexes** to prevent race conditions in shared memory.
* Properly **clean up** IPC resources (`shm_unlink`, `mq_unlink`, `sem_unlink`, etc.).
* Handle **access control** for IPC objects (permissions, user/group).

---

## üí° Tip: Tools to Debug IPC

* `ipcs` and `ipcrm` for System V IPC
* `lsof | grep pipe` to inspect open pipes
* `netstat`, `ss`, and `tcpdump` for sockets

---

## ‚úÖ Summary

C++ supports IPC via system APIs (POSIX, System V, or BSD sockets), typically via:

* `unistd.h`, `sys/socket.h`, `sys/shm.h`, `sys/sem.h`, `mqueue.h`, etc.
* Libraries like **Boost.Interprocess** or **ZeroMQ** for higher abstraction

If you‚Äôd like practical use-cases (e.g., chat app, logging service, file sync) or **interview-level questions with code**, I can provide that next.
