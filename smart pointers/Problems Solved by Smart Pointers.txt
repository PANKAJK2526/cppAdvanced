Smart pointers in C++ solve several common **memory management** issues that arise when using **raw pointers**:

---

### âœ… 1. **Memory Leaks**

#### ðŸ”´ Problem (raw pointer):

```cpp
void leakMemory() {
    int* ptr = new int(10);
    // Forgot to delete ptr => memory leak
}
```

#### âœ… Solution (smart pointer):

```cpp
#include <memory>

void noLeak() {
    std::unique_ptr<int> ptr = std::make_unique<int>(10);
    // Automatically deallocated when ptr goes out of scope
}
```

---

### âœ… 2. **Dangling Pointers (Use-after-free)**

#### ðŸ”´ Problem:

```cpp
void danglingPointer() {
    int* ptr = new int(5);
    delete ptr;
    *ptr = 10;  // undefined behavior (use-after-free)
}
```

#### âœ… Solution:

```cpp
#include <memory>

void safePointer() {
    std::unique_ptr<int> ptr = std::make_unique<int>(5);
    // After going out of scope, memory is safely freed and can't be reused
}
```

---

### âœ… 3. **Double Delete**

#### ðŸ”´ Problem:

```cpp
void doubleDelete() {
    int* ptr = new int(5);
    delete ptr;
    delete ptr;  // double delete => undefined behavior
}
```

#### âœ… Solution:

```cpp
#include <memory>

void safeDelete() {
    std::unique_ptr<int> ptr = std::make_unique<int>(5);
    // Memory will be deleted only once automatically
}
```

---

### âœ… 4. **Exception Safety**

#### ðŸ”´ Problem:

```cpp
void exceptionUnsafe() {
    int* ptr = new int(5);
    throw std::runtime_error("error");
    delete ptr; // never reached, memory leaked
}
```

#### âœ… Solution:

```cpp
#include <memory>

void exceptionSafe() {
    std::unique_ptr<int> ptr = std::make_unique<int>(5);
    throw std::runtime_error("error"); // memory auto-freed
}
```

---

### âœ… 5. **Shared Ownership**

#### ðŸ”´ Problem (manual reference counting is error-prone):

```cpp
class Shared {
    int* data;
public:
    Shared() { data = new int(100); }
    ~Shared() { delete data; }
};
```

#### âœ… Solution:

```cpp
#include <memory>

void sharedOwnership() {
    std::shared_ptr<int> p1 = std::make_shared<int>(100);
    std::shared_ptr<int> p2 = p1;  // reference count increases
}
```

---

### âœ… 6. **Cyclic References (solved using `weak_ptr`)**

#### ðŸ”´ Problem:

```cpp
struct B;
struct A {
    std::shared_ptr<B> b;
};
struct B {
    std::shared_ptr<A> a; // strong reference cycle => memory leak
};
```

#### âœ… Solution:

```cpp
#include <memory>

struct B;
struct A {
    std::shared_ptr<B> b;
};
struct B {
    std::weak_ptr<A> a;  // weak_ptr breaks the cycle
};
```

---

### Summary Table

| Problem          | Solution     |
| ---------------- | ------------ |
| Memory leak      | `unique_ptr` |
| Dangling pointer | `unique_ptr` |
| Double delete    | `unique_ptr` |
| Exception safety | `unique_ptr` |
| Shared ownership | `shared_ptr` |
| Cyclic reference | `weak_ptr`   |

Want a real-world project example using these?
